<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Jeu Avion Espace - Desktop</title>
    <link rel="stylesheet" href="styles.css">
</head>
<body class="desktop-page">
    <div id="space-road">
        <div id="lane"></div>

        <!-- HUD -->
        <div id="hud">
            <div id="score">Distance : 0 m | Vitesse : 0.0</div>
            <div id="hud-line">
                Obstacles dÃ©truits : <span id="obstacle-count">0</span>
            </div>
        </div>

        <!-- Game over -->
        <div id="game-over">ðŸ’¥ Crash ! Cliquez pour recommencer</div>

        <!-- Avion -->
        <div id="ship">
            <img src="fighter-jet.svg" alt="Avion de chasse" />
            <div id="ship-thrust"></div>
        </div>
    </div>

    <script src="/socket.io/socket.io.js"></script>
    <script>
        const socket = io();

        const spaceRoad = document.getElementById('space-road');
        const lane = document.getElementById('lane');
        const ship = document.getElementById('ship');
        const scoreElement = document.getElementById('score');
        const obstacleCountElement = document.getElementById('obstacle-count');
        const gameOverElement = document.getElementById('game-over');

        const SHIP_WIDTH = 70;
        let shipX = (spaceRoad.clientWidth - SHIP_WIDTH) / 2;
        const SHIP_BASE_BOTTOM = 80;

        // Vitesse de base + boost (plus lent)
        const BASE_SPEED = 1.8;     // avance tout seul mais tranquille
        let boost = 0;              // boost additionnel
        const MAX_BOOST = 5;
        const ACCEL_STEP = 0.6;
        const FRICTION = 0.25;

        // score
        let distance = 0;
        let destroyed = 0;
        let displaySpeed = BASE_SPEED;

        // scroll
        let backgroundOffset = 0;
        let lastFrameTime = performance.now();

        // obstacles / tirs
        const obstacles = [];
        const projectiles = [];
        let spawnTimer = 0;
        const SPAWN_INTERVAL = 20;

        let isGameOver = false;

        function updateShipPosition() {
            ship.style.left = shipX + 'px';
            ship.style.bottom = SHIP_BASE_BOTTOM + 'px';
        }

        updateShipPosition();

        function getLaneBounds() {
            const laneRect = lane.getBoundingClientRect();
            const roadRect = spaceRoad.getBoundingClientRect();

            const minX = laneRect.left - roadRect.left;
            const maxX = laneRect.right - roadRect.left - SHIP_WIDTH;
            return { minX, maxX };
        }

        // --------- commandes depuis mobile ---------
        socket.on('update', (data) => {
            if (isGameOver) return;
            if (!data || typeof data.action !== 'string') return;

            if (data.action === 'accelerate') {
                boost = Math.min(MAX_BOOST, boost + ACCEL_STEP);
                ship.classList.add('accelerating');
            }

            // on peut toujours tourner, mÃªme sans accÃ©lÃ©ration
            if (data.action === 'move') {
                const step = 16; // un peu moins violent aussi
                if (data.direction === 'left') {
                    shipX -= step;
                } else if (data.direction === 'right') {
                    shipX += step;
                }

                const { minX, maxX } = getLaneBounds();
                shipX = Math.max(minX, Math.min(maxX, shipX));
                updateShipPosition();
            }
        });

        socket.on('shoot-projectile', () => {
            if (isGameOver) return;
            createProjectile();
        });

        // --------- tirs ---------
        function createProjectile() {
            const proj = document.createElement('div');
            proj.className = 'projectile';

            const shipRect = ship.getBoundingClientRect();
            const roadRect = spaceRoad.getBoundingClientRect();

            const x = shipRect.left - roadRect.left + shipRect.width - 10;
            const y = shipRect.top - roadRect.top + shipRect.height / 2 - 9;

            proj.style.left = x + 'px';
            proj.style.top = y + 'px';

            spaceRoad.appendChild(proj);
            projectiles.push({ el: proj, x, y });
        }

        // --------- obstacles ---------
        function spawnObstacle() {
            const obs = document.createElement('div');
            obs.classList.add('obstacle');

            const typeRand = Math.random();
            if (typeRand < 0.4) obs.classList.add('obstacle--asteroid');
            else if (typeRand < 0.8) obs.classList.add('obstacle--cloud');
            else obs.classList.add('obstacle--sun');

            const laneRect = lane.getBoundingClientRect();
            const roadRect = spaceRoad.getBoundingClientRect();
            const margin = 25;

            const minX = laneRect.left - roadRect.left + margin;
            const maxX = laneRect.right - roadRect.left - margin - 38;

            const x = minX + Math.random() * (maxX - minX);
            const y = -50;

            obs.style.left = x + 'px';
            obs.style.top = y + 'px';

            spaceRoad.appendChild(obs);
            obstacles.push({ el: obs, x, y });
        }

        function resetGame() {
            isGameOver = false;
            gameOverElement.style.display = 'none';

            boost = 0;
            distance = 0;
            destroyed = 0;
            backgroundOffset = 0;
            spawnTimer = 0;

            obstacles.forEach(o => o.el.remove());
            projectiles.forEach(p => p.el.remove());
            obstacles.length = 0;
            projectiles.length = 0;

            shipX = (spaceRoad.clientWidth - SHIP_WIDTH) / 2;
            updateShipPosition();
            ship.classList.remove('accelerating');
            updateHUD();
        }

        gameOverElement.addEventListener('click', resetGame);
        spaceRoad.addEventListener('click', () => {
            if (isGameOver) resetGame();
        });

        function updateHUD() {
            scoreElement.textContent =
                `Distance : ${Math.floor(distance)} m | Vitesse : ${displaySpeed.toFixed(1)}`;
            obstacleCountElement.textContent = destroyed;
        }

        function rectsOverlap(r1, r2) {
            return !(
                r1.right < r2.left ||
                r1.left > r2.right ||
                r1.bottom < r2.top ||
                r1.top > r2.bottom
            );
        }

        // --------- boucle de jeu ---------
        function gameLoop(timestamp) {
            const dt = (timestamp - lastFrameTime) / 16.67;
            lastFrameTime = timestamp;

            if (!isGameOver) {
                // friction sur le boost (la vitesse de base reste)
                if (boost > 0) {
                    boost = Math.max(0, boost - FRICTION * dt);
                } else {
                    ship.classList.remove('accelerating');
                }

                const currentSpeed = BASE_SPEED + boost;
                displaySpeed = currentSpeed;

                // scroll espace plus lent
                backgroundOffset += currentSpeed * dt * 2.0;
                spaceRoad.style.backgroundPositionY = `${backgroundOffset}px`;

                // distance
                distance += currentSpeed * dt * 0.8;

                // spawn obstacles : rythme dÃ©pend de la vitesse
                spawnTimer += dt * (currentSpeed / BASE_SPEED);
                if (spawnTimer >= SPAWN_INTERVAL) {
                    spawnTimer = 0;
                    spawnObstacle();
                }

                const roadRect = spaceRoad.getBoundingClientRect();
                const shipRect = ship.getBoundingClientRect();

                // update obstacles (descente plus douce)
                for (let i = obstacles.length - 1; i >= 0; i--) {
                    const o = obstacles[i];
                    o.y += currentSpeed * dt * 2.3;
                    o.el.style.top = o.y + 'px';

                    const obsRect = o.el.getBoundingClientRect();

                    // collision avion / obstacle
                    if (rectsOverlap(shipRect, obsRect)) {
                        isGameOver = true;
                        gameOverElement.style.display = 'block';
                    }

                    // sorti de l'Ã©cran
                    if (obsRect.top > roadRect.bottom) {
                        o.el.remove();
                        obstacles.splice(i, 1);
                    }
                }

                // projectiles un peu plus lents
                for (let pIndex = projectiles.length - 1; pIndex >= 0; pIndex--) {
                    const p = projectiles[pIndex];
                    p.y -= 22 * dt * 2.5;
                    p.el.style.top = p.y + 'px';

                    const projRect = p.el.getBoundingClientRect();

                    if (projRect.bottom < roadRect.top) {
                        p.el.remove();
                        projectiles.splice(pIndex, 1);
                        continue;
                    }

                    // collision projectile / obstacle
                    for (let oIndex = obstacles.length - 1; oIndex >= 0; oIndex--) {
                        const o = obstacles[oIndex];
                        const obsRect = o.el.getBoundingClientRect();

                        if (rectsOverlap(projRect, obsRect)) {
                            o.el.classList.add('exploding');
                            setTimeout(() => o.el.remove(), 180);

                            obstacles.splice(oIndex, 1);
                            p.el.remove();
                            projectiles.splice(pIndex, 1);

                            destroyed++;
                            break;
                        }
                    }
                }

                updateHUD();
            }

            requestAnimationFrame(gameLoop);
        }

        requestAnimationFrame(gameLoop);
    </script>
</body>
</html>
